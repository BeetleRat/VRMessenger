@mainpage Многопользовательский интерфейс для общения в виртуальной реальности с использованием аватаров

@tableofcontents

@section section_water Общее описание работы скриптов
## Дополнительные ассеты
Для реализации логики работы приложения в проект были импортированы дополнительные ассеты:
- [Oculus Integration](https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022) - для работы со шлемом виртуальной реальности Oculus Quest 2;
- [PUN 2 - FREE](https://assetstore.unity.com/packages/tools/network/pun-2-free-119922) - для реализации сетевого взаимодействия;
- [Photon Voice 2](https://assetstore.unity.com/packages/tools/audio/photon-voice-2-130518) - для реализации голосового чата;
- [LeanTween](https://assetstore.unity.com/packages/tools/animation/leantween-3595) - для плавного перемещения объектов;
- [ReadyPlayerMe](https://docs.readyplayer.me/ready-player-me/integration-guides/unity/quickstart) - для загрузки моделей аватаров созданных при помощи сервиса Ready Player Me;
- [WireBuilder](https://www.patreon.com/login?ru=https%3A%2F%2Fwww.patreon.com%2Ffile%3Fh%3D77014259%26i%3D12762600) - для создания проводов.

## Менеджеры
Основным скриптом является NetworkManager. В нем осуществляется подключение к серверу, отключение от сервера, создание и подключение к лобби, создание и подключение к комнате, отключение от комнаты, отключение от лобби, отключение от сервера, обновление списка существующих комнат, спавн игрока на сервере, а также генерация случайного изначального имени игрока. В полях данного скрипта указываются типы доступных комнат в формате класса RoomSettings. RoomSettings это класс, хранящий параметры комнат, к которым будет производится подключение: название комнаты, name, количество игроков в комнате, будет ли комната видима, ID сцены, из которой будет создана комната.

Скрипту NetworkManager необходимо загружать различные сцены. Для этой цели ему передается скрипт SceneChanger, отвечающий за смену сцен.

В процессе работы приложения регулярно необходимо будет синхронизировать состояния объектов с сервером. Для отправки текущего состояния на сервер, а также обработки пришедших на сервер состояний используется скрипт NetworkVariables.

Для отладки приложения необходимо логгировать отлаживаемые компоненты. При разработке не всегда удобно, а иногда и невозможно смотреть в консоль движка Unity. С этой целью был написан скрипт VRLogger, выводящий приходящие в него логи на текстовое поле интерфейса внутри приложения. Таких скриптов в сцене может быть много. Мы можем дать каждому игроку по экрану лога. Что бы при логгировании не искать каждый раз все VRLogger в сцене, был написан скрипт VRLoggersManager. VRLoggersManager выводит лог во все VRLogger на сцене.

Игрок может переключаться между типами контроллеров. Он может осуществлять взаимодействие с виртуальной реальностью при помощи контроллеров Oculus Touch, а может отложить их в сторону и начать взаимодействовать при помощи своих собственных рук. Подобное переключение необходимо отслеживать. Это нужно как для корректного отображения типа контроллеров на сервере, так и для использования корректных якорей на теле игрока. С целью отслеживания данного переключения создан скрипт ControllerEvents.

Приложению необходим доступ к микрофону, для работы голосового чата. Однако в стартовой сцене нет компонентов, требующих доступа к микрофону, т.к. в стартовой сцене отсутствует голосовой чат. Таким образом возникает проблема: пользователь запускает приложение, не давая ему разрешение на доступ к микрофону, и лишь установив соединение с сервером и перейдя в комнату голосового чата приложение запросит доступ к микрофону. В таком случае операционная система остановит приложение и попросит пользователя предоставить доступ к микрофону, остановка приложения во время того, как пользователь присоединился к комнате будет расценена Photon, как отключение от сервера и пользователя выкинет из приложения, даже если он предоставит доступ. Во избежание такой ситуации, необходимо запросить доступ к микрофону сразу при запуске приложения. С этой целью был создан скрипт PermissionRequester. Данный скрипт запрашивает разрешение при запуске приложения и отключается.

Скрипты NetworkManager, SceneChanger, NetworkVariables, VRLoggersManager, ControllerEvents, PermissionRequester должны всегда оставаться в сцене, и более того, при смене сцены они должны сохранять свое состояние. Для этого к ним применен паттерн Singleton, реализованный в скрипте EasySingleton.

## Prefab игрока
NetworkManager при подключении к комнате спавнит на сервере prefab игрока. Рассмотрим, что это такое:

\image html PlayerPrefab.png width=500
<div style="text-align: center;">
    Prefab спавнемого игрока
</div>

Данный prefab содержит голову, левую и правую руки, аватар пользователя, UI табличку с именем пользователя. Голова содержит компонент Speaker, отвечающий за передачу голоса на сервер. Так же положение головы и рук связано с соответствующими частями тела аватара пользователя при помощи скрипта MapAvatarBody, который связывает части тела с контроллерами при помощи класса MapRigTransform.

В руках храниться компонент ControllerTypeController, отвечающий за смету типа отображаемых на сервере контроллеров. Внутри этого компонента хранятся отображаемые контроллеры: Controller и Hand. Controller управляется скриптом ControllerAnimationUpdater. Этот скрипт осуществляет синхронизацию анимации контроллера, отображаемого локально и контроллера, отображаемого на сервере. Hand, в свою очередь, управляется скриптом GostHandTransformUpdater. Данный скрипт синхронизирует положение и поворот всех суставов отображаемой на сервере руки и HandSynthetic локального игрока. 

Компонент AvatarInfo определяет основные настройки аватара: активен ли аватар; путь до prefab-а, который будет передан скрипту NetworkManager; изображение аватара в меню.

Аватар игрока создается из модели Ready Player Me. Для работы с моделями Ready Player Me был создан подкласс AvatarInfo хранящий в себе модель Ready Player Me и пол модели (мужской или женский) – RPMAvatarInfo.

В prefab-е игрока хранятся две стандартные модели Ready Player Me – мужская и женская. Благодаря параметру класса RPMAvatarInfo, выбирается одна из этих моделей и ее составные части заменяются на части модели указанной в RPMAvatarInfo. За замену частей стандартной модели на части модели из RPMAvatarInfo отвечает класс RPMAvatarParser. Для замены конкретной части тела RPMAvatarParser использует класс MeshSwapper.

Для вывода имени в табличку имени пользователя используется скрипт UIDisplayPlayerName. Что бы табличка всегда поворачивалась лицом к пользователю, используется скрипт ObjectToMainCameraRotator.

Весь prefab игрока контролируется скриптом NetworkPlayer, который обеспечивает синхронизацию положения контроллеров/рук и головы игрока локального и отображения этих частей на сервере. Так же данный скрипт следит за синхронизацией состояния типа контроллеров. 

Если NetworkPlayer работает на стороне сервера, то на стороне клиента присутствует компонент HandView, к которому NetworkPlayer обращается за текущим положением и состоянием рук.

HandView должен быть прикреплен к рукам локального игрока, чтобы корректно передавать их положение на сервер. Причем при смене типа контроллера он должен перепрыгивать с рук на контроллеры и наоборот. Вручную размещать данные компоненты на игроке неудобно. А потому был написан скрипт AttachToPlayersBody. Данный скрипт прикрепляет компонент к якорю, указанному в его свойствах. Таким образом, мы создаем якорь на руках и контроллерах, а скрипт AttachToPlayersBody во время запуска игры крепит к данным якорям указанный компонент. Это позволяет хранить все прикрепляемые к игроку объекты в отдельном месте, а prefab игрока открывать только для настроек игрока и добавления якорей.

## UI скрипты
В лобби присутствуют UI кнопки, которые должны обращаться к NetworkManager, но NetworkManager нельзя добавлять в OnClick события, т.к. после смены сцен, в лобби вернется текущий NetworkManager, а указанный в изначальной сцене будет уничтожен. С целью исправить это, а также предоставить кнопкам удобный интерфейс взаимодействия с NetworkManager через OnClick события, был создан компонент NetworkManagerProvider.

Развивая идеи NetworkManagerProvider, появился компонент ComponentCatcher. В сцене могут появляться объекты изначально там не находящиеся. Это singleton объекты пришедшие из другой сцены, спавнемые аватары или просто объекты. И всем им могут быть нужны различные объекты из текущей сцены. ComponentCatcher это компонент, настраиваемый instance которого находиться в каждой сцене. Данный компонент при старте сцены отлавливает все часто используемые объекты и объекты, до которых не добраться во время редактирования сцены: VRLoggersManager, NetworkManager, ControllerEvents и подобные. В дальнейшем, если какому-либо скрипту понадобиться NetworkManager, он обратиться за ним к ComponentCatcher.

В лобби состояние главного меню должно изменяться в зависимости от текущего состояния подключения к серверу. Например, пока происходит подключение меню должно отображать preloader, а когда подключение завершилось скрыть его и показать пункты меню. За динамическую смену слоев интерфейса главного меню в зависимости от сигналов приходящих от NetworkManager, отвечает компонент ChangeUILayer.

При выборе комнаты игроку должен предоставляться список комнат активных в данный момент. Этот список реализуется скриптами RoomListItem – элемент списка, и UIRoomListController – непосредственно список, показывающий RoomListItem в UI.

Схожим образом организован список аватаров. Список аватаров реализован в скрипте AvatarList. Данный список сканирует папку Resources/Avatars на наличие prefab-ов с компонентом AvatarInfo. Если были найдены prefab-ы с таким компонентом, у которого установлен флаг активности, из такого prefab-а создается пункт списка AvatarListItem. 

В исходной сцене находится UI элемент для установки имени пользователя. За установку имени пользователя отвечает скрипт ChangeNetworkName. Если оно не задано, его генерирует скрипт NetworkManager.

Для ввода имени пользователя используется виртуальная UI клавиатура. Логика работы кнопки клавиатуры описывается в скрипте KeyboardButton. А логика самой клавиатуры в скрипте VirtualKeyboardController. Для предоставления UI элементам удобного доступа к виртуальной клавиатуре используется скрипт KeyboardProvider. 

У игрока на запястье присутствует несколько меню. Эти меню не всегда включены и когда одно меню становится видимым, предыдущее исчезает. Для скрытия/появления меню используется скрипт InterfaceHider. А для смены одного меню на другое используется скрипт MenuSwapper.

## Скрипты для устранения возникших ошибок
При взаимодействии игрока с предметами возникал ряд ошибок, следующие скрипты были написаны для исправления данных ошибок:
- OwnershipTransfer - В Photon у интерактивных объектов есть владелец. И Photon синхронизирует с сервером только данные владельца объекта. Владельцем становится первый схвативший объект. Но нам необходимо, что бы все пользователи могли взаимодействовать с объектами. Для этого необходимо передавать владение объектом тому пользователю, который взял объект. OwnershipTransfer совершает передачу прав владения объектом тому, кто взял этот объект.
- RigidBodySycn – Photon синхронизирует положение, скорость, ускорение объекта. Но не синхронизирует isKinematic. Из-за чего происходит ошибка: когда игрок берет предмет, локально, данный предмет становиться Kinematic, а на сервере получается, что объект поднят в воздух и он начинает падать, пока Photon снова не синхронизирует его положение. Из-за данной ошибки взятый в руку предмет начинает прыгать в руку и вниз. RigidBodySycn синхронизирует isKinematic объекта с сервером и исправляет данную ошибку.

## Скрипты для взаимодействия с аудио
Взаимодействие с микрофоном осуществляется скриптами MicrophoneController и MicrophoneNetworkSettings. MicrophoneController контролирует локальные действия с микрофоном, а MicrophoneNetworkSettings отвечает за синхронизацию локальных действий на сервере.

В некоторых сценах играет фоновая музыка. Она может отвлекать или просто не нравиться пользователю. Для контроля нескольких источников звука, в частности фоновой музыки, используется скрипт AudioController.

## Скрипты для расопзнования жестов
Для распознавания жестов используется абстрактный класс GestureDetector. Его наследники могут отслеживать жесты и осуществлять действия при их обнаружении.

Компонент GestureProperties хранит в себе информацию о пальцах, загнутых в указанном жесте.

## Вспомогательные скрипты
ButtonTextChanger – при наведении на UI кнопку записывает в указанное текстовое поле указанный текст;

GifAnimation – создает анимацию из входных кадров;

SetupRoomName – записывает имя текущей комнаты в указанное текстовое поле;

BackFromFloor – возвращает объект в исходное положение если он соприкоснулся с объектом Floor.

## Скрипты электрической цепи
Для демонстрации возможности проведения лабораторной работы в виртуальной реальности, была разработана симуляция эксперимента по расчету силы тока и напряжения в электрической цепи.

Логика изменения параметров электрической цепи описывается скриптом ElectricalCircuit. Электрическая цепь состоит из подклассов класса ElectricalElement: PowerSupply, Milliammeter, Voltmeter, Resistor, Rheostat, MultiClema, WireElement.

Элементы присоединяются друг к другу при помощи клемм, имеющих компоненты WireInput и WireOutput. Провод WireElement на своих концах имеет компонент WireOutput. А остальные элементы имеют в своем составе две клеммы с компонентом WireInput.

Если два конца провода будут слишком далеко от друга, то в текстуре провода будут появляется глитчи. Во избежание этого, к концам провода прикреплен компонент MoveCloserIfDistanceIsLarge.

Указатель реостата (Rheostat) при перемещении издает щелкающий звук. Воспроизведение звука при перемещении объекта реализовано в скрипте PlayAudioWhenObjectMove.

Вольтметр (Voltmeter) и миллиамперметр (Milliammeter) имеют в своем составе шкалу измерений и стрелку, которая поворачивается в зависимости от текущего значения параметра прибора. Реализация поворота стрелки, в зависимости от текущего значения описывается в скрипте ScaleWithPointer.

@section section_bugs Известные ошибки
## Не синхронизировано состояние микрофона
При заходе нового игрока в сцену он не слышит уже находящихся в ней людей, а они его, до тех пор, пока игроки не включат/выключат компонент Recorder. Баг воспроизводиться только при запуске с различных устройств, подключенных к различным точкам доступа (при запуске 2-х приложений с одного компьютера все работает правильно).

Баг может быть связан со скриптами MicrophoneController, MicrophoneNetworkSettings и ComponentCatcher. В данных скриптах используется компонент Recorder. Так же при внесении случайных изменений в эти скрипты, баг исчезал. Так же возможно он связан с настройкой компонентов Photon: Recorder, Speaker, Pun Voice Client.

Предполагаемый путь решения. Создать новую сцену. Убрать из нее элементы WatchMenu, которые взаимодействуют с микрофоном. Попробовать в чистой сцене получить состояние, при котором все работает. Добавлять компоненты по одному, чтобы найти какой компонент вызывает ошибку.

 ## Периодически kinematic не устанавливается обратно в false
Данная ошибка была выявлена при тестировании. Возникает она когда пользователь берет предмет не из пространства, а из рук другого пользователя (или собственных). OwnershipTransfer и RigidBodySycn задействованы при данном процессе, скорее всего нужно переписать скрипт RigidBodySycn.

*Возможно нужно избавиться от скрипта RigidBodySycn вовсе и найти другой способ решения проблемы синхронизации RigidBody, при подключении нового игрока к серверу.*

## Объекты нельзя бросать рукой
По идее у Oculus Integration для бросков есть механизм. Но скрипт RigidBodySycn скорее всего препятствует его корректной работе. 

Нужно попробовать бросать объекты без RigidBodySycn, если получиться, то добавить скрипт и изменять его таким образом, чтобы броски работали.

*Возможно нужно избавиться от скрипта RigidBodySycn вовсе и найти другой способ решения проблемы синхронизации RigidBody, при подключении нового игрока к серверу.*

## Баги, которые пока что не получилось воспроизвести
*Данные ошибки были замечены, но при попытке воспроизвести условия при которых произошла ошибка – ошибка не повторялась.*

NetworkManeger может отключить человека от комнаты, но не перенести в стартовую сцену - приложение в таком случае софтлочится, т.к. из комнаты не выйти.

После возвращения в первую сцену выход перестает работать (в билде).

@section section_future Планы на будущее 
- Создать лекционную аудиторию. В аудитории должен быть UI в который загружается презентация Power Point;
- Переработать watchmenu;
- Добавить меню помощи в watchmenu. В данном окне будут инструкции по телепортации в сценах.